<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
	"http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
	<title>Handler pipeline and filters</title>
	<link href="../demo/css/oocss.css" rel='stylesheet'/>
	<link rel="stylesheet" type="text/css" href="introduction.css" media="all">
	<link href='../demo/SyntaxHighlighter/styles/shCore.css' rel='stylesheet'/>
	<link href='../demo/SyntaxHighlighter/styles/shThemeDefault.css' rel='stylesheet'/>
	<script src='../demo/SyntaxHighlighter/scripts/XRegExp.js'></script>
	<script src='../demo/SyntaxHighlighter/scripts/shCore.js'></script>
	<script src='../demo/SyntaxHighlighter/scripts/shBrushJScript.js'></script>
	<script src='../demo/SyntaxHighlighter/scripts/shBrushXml.js'></script>
	<script src='../demo/SyntaxHighlighter/scripts/shBrushCss.js'></script>
	<script src='analytic.js'></script>
	<script language="javascript" type="text/javascript">
		SyntaxHighlighter.defaults.gutter = false;
		SyntaxHighlighter.defaults.toolbar = false;
		SyntaxHighlighter.config.bloggerMode = true;
		SyntaxHighlighter.all();
	</script>
</head>
<body>
<div class="page oldSchool">
<h2>Handler pipleline and filters</h2>

<p>Handler is where the work is done. As we have changed event binding to event subscription,
	we also need the way we write handler. The good news is that you old handlers probabaly continue
	to work without change or with a very small change. Let's revisit the handler in "hello world"
	example.
</p>

<pre class="brush:javascript">
	//model "helloApp.name" subscribe an event of text box "txtName"
	via( "helloApp.name" ).subscribe( "$#txtName", "change", function( e ) {
	    this.set( e.publisher.val() );
	} );
	//view #divMessage subscribe an event of model "test.message"
	$( "#divMessage" ).subscribe( "helloApp.message", "afterUpdate", function( e ) {
	    this.html( e.publisher.get() );
	} );
</pre>

<p>In jQuery event handler, "this" variable refer to e.target. In via.js handler, "this" is
	subscriber. If the event is subscribed by a model, then the subscriber is a proxy. If the event
	is subscribed by a view, then the subscriber is a jQuery object of the view.
</p>

<h3>Event arguement of model event and view event</h3>

<p>
	Although the subscriptions of of model event and view event are both supported in via.js, but
	the underlining implementations are still different. via.js try to normalize the behavior of
	these two event implementation by making the event arguement the same. The following chart list
	the member of event arguement in model event handler and view event handler. The highlighted
	parts are the shared members. The other properties are specific to model event or view event.
</p>

<div class="data simpleTable">
	<table>
		<col style="width:220px">
		<col style="width:auto;">
		<col style="width:220px">
		<tr>
			<td>Event argument members(e.xx)<br/>
			</td>
			<td>model event argument</td>
			<td>view event argument</td>
		</tr>
		<tr>
			<td>instance of</td>
			<td>via.Event</td>
			<td>jQuery.Event</td>
		</tr>
		<tr class="commonFeature">
			<td>publisher</td>
			<td>
				a model proxy
			</td>
			<td>augmented by via.js $(e.currentTarget)</td>
		</tr>
		<tr class="commonFeature">
			<td>originalPublisher</td>
			<td>
				a model proxy
			</td>
			<td>augmented by via.js $(e.target)</td>
		</tr>
		<tr class="commonFeature">
			<td>handler</td>
			<td>
				supported by via.js <br/>(handler pipeline)
			</td>
			<td>augmented by via.js <br/>(handler pipeline)</td>
		</tr>
		<tr class="commonFeature">
			<td>type</td>
			<td>
				supported by via.js
			</td>
			<td>
				supported by jQuery.Event
			</td>

		</tr>

		<tr class="commonFeature">
			<td>stopPropagation()</td>
			<td>
				supported by via.js
			</td>
			<td>supported by jQuery.Event</td>
		</tr>
		<tr class="commonFeature">
			<td>stopImmediatePropagation()</td>
			<td>
				supported by via.js
			</td>
			<td>supported by jQuery.Event</td>
		</tr>
		<tr>
			<td>proposed</td>
			<td>
				availabe in beforCreate, beforeUpdate event
			</td>
			<td>n/a</td>
		</tr>
		<tr>
			<td>removed</td>
			<td>
				availabe in afterDel, afterUpdate event
			</td>
			<td>n/a</td>
		</tr>
		<tr>
			<td>level</td>
			<td>
				supported, a number show the level from current model to the original model
			</td>
			<td>n/a</td>
		</tr>
		<tr>
			<td>stopCascade()</td>
			<td>
				supported, when called the event will not be broadCast to dependent property
			</td>
			<td>n/a</td>
		</tr>
		<tr>
			<td>error()</td>
			<td>
				supported, when called in beforeUpdate, beforeCreate event handler, will abort
				update, create operations
			</td>
			<td>n/a</td>
		</tr>
		<tr>
			<td>isDependent()</td>
			<td>
				supported, true if publisher model is not the ascendent of original publisher
			</td>
			<td>n/a</td>
		</tr>
		<tr>
			<td>Other jQuery Event propeteries such as target, related target, pageX, pageY, ...
			</td>
			<td>n/a</td>
			<td>supported by jQuery.Event</td>
		</tr>
	</table>
</div>


<h3>Reusability</h3>

<p> When function does not have external dependencies, the function is stateless and reusable. When
	we change event binding to event subscriptions, in lots of case (not all the case), we can keep
	our handler stateless, just like the two handler above. (There are two local varible, "this" and
	"e".) So the subscription handler tends to be more reusable than binding handler.
</p>

<h3>Composibility</h3>

<p>
	In viajs the work that an subscription handler need to finish is very small and very
	predictable. Most of the work can be split into the following three tasks.
</p>

<ol class="simpleList">
	<li>Get the value from the publisher (Getter)</li>
	<li>Convert the value of previous step into an other value (Converter)</li>
	<li>Update subscriber with the value of previous step (Setter)</li>
</ol>

<p>We can build a handler by composing these tasks together. This is actually a pattern named<a
	href="http://www.eaipatterns.com/PipesAndFilters.html">"Pipes and Filters"</a>. If a filter
	is stateless, it can be also resusable.
</p>

<h3>Handler is a pipeline</h3>

<p>The subscription handler in via.js is not a implemented as a function, instead, it is a pipeline
	object which consist of 1 to 5 filter (<strong>getter, setter, converter, initializer,
		finalizer</strong>), the only required filter is <strong>getter</strong>. The initializer
	is executed when a subscription is created. This filter will be only called once. The other
	four handler will executed when event is fired, below is how these four filters are executed.
</p>

<!--	These four filter
	executed in the context of subscriber, "this" is the subscriber.


	Another filter (<strong>initializer</strong>) are used during event subscription is created.
	This filter is executed in the context of global object. "this" is the global object.
-->
<ol class="simpleList">
	<li>
		The handler pipleline start off with getter. It use getter get the value from publisher and
		save it to current value. But you can also combine all the logic in a this filter, so that
		there is not need in other filter. You should do if the logic can not be composed by
		existing filter.
		Pipeline check whether a current value is a promise, if it is promise wait for the promise
		to resolve a value and save back the current value, then continue the next step, otherwise
		continue the next step.
	</li>
	<li>Pipleline check whether there is a converter. If there is, convert the current value, and
		save it back the current value.
	</li>
	<li>
		If the current value is undefined, pipeline stop. If the current value is a promise,
		wait for the promise resolve a value, then continue next step, other wise continue next
		step.
	</li>
	<li>
		Pipeline check whether there is a setter. If there is a setter, pipeline pass current value
		into setter and run it.
	</li>
	<li>
		Pipline check whether there is finalizer. If there is a finalizer, pipeline pass current
		value into setter and run it.
	</li>
</ol>

<p>Promise is introduced in jQuery since 1.5, the support of promise in pipeline is a very
	powerful feature. We will talk about its usage later.</p>

<h3>Filters</h3>


<p> Each filter can be used in one of four forms.
</p>

<ol class="simpleList">
	<li>function filter</li>
	<li>common filter</li>
	<li>publisher method or subscriber method</li>
	<li>model helper</li>
</ol>

<h4>Function filter</h4>

<p>Function filter is the native form of filter, all forms of filter will be converted to filter
	function.</p>

<ol class="simpleList">
	<li>getter (required, get the value of publisher or do all the work of a handler. The "this"
		variable inside is the subscriber.)
		<pre class="brush:javascript">
			function get(e) {
				//you can do all your work in the filter
				//and return undefined
				//or
				//get the value from e.publisher
				//return a value so that the next filter can contine the processing
			}
		</pre>
	</li>
	<li>converter (optional, convert the value returned from getter. The "this"
		variable inside is the subscriber.)
	<pre class="brush:javascript">
		function convert(value, e) {
			//return a new value by converting the value paramter
			// or return a promise which will resolve a converted value.
		}
	</pre>
	</li>

	<li>setter (optional, update subscriber with the value returned from converter. The "this"
		variable inside is the subscriber.)
	<pre class="brush:javascript">
		function set(value, e) {
			//set this
		}
	</pre>
		<p>In via.js, one creative usage of setter is to append the rendered markup into DOM
			element.</p>
	</li>
	<li>
		finalizer (optional, action will perform on the side effect that setter has created. The
		"this" variable is the subscriber.).
		<pre class="brush:javascript">
			function finalize(value, e) {
				//value is value which is passed into set filter
			}
		</pre>
		<p>
			In via.js, one of the usage of finalizer is used to parse the
			markup appended into DOM to build declarative subscriptions.
		</p>
	</li>
	<li>initializer(optional, it is called during subscription is created. The "this"
		variable inside is the global object.)
		<pre class="brush:javascript">
			function initialize ( publisher, subscriber, pipeline, options ) {
				//publisher, subscribe are either jQuery object or model proxy
				//pipeline is the pipeline being build
				//options is the options that passed into
				//subscriber.subscribe(publisher, events, handler, options)
			}
		</pre>
		<p>
			It is useful when create a customized copy of reusable handlers, and wrapping
			and third party widget.
		</p>
	</li>
</ol>

<h4>Common filter</h4>

<p>Common filters are the filters which can be reused in a handler. To create common filter we
	can use the following code.</p>

<pre class="brush:javascript">
	via.filters.getters.mygetter = function (e) {};
	via.filters.converters.myconverter = function( value ) {};
	via.filters.setters.mysetter = function (value, e) {};
	via.filters.finalizers.myfinalizer = function (value, e) {};
	via.filters.initializers.myinitializer = function (publisher, subscriber, pipeline, options) {};

	//use "*filterName" to reference the filter.
	//e.g
	$view.subscribe( "color", "init afterUpdate", "*mygetter *mysetter *myconverter *myfinalizer *myinitializer" );

</pre>

<p>
	A common filter expression is a string. For the above common converter, we can use string
	"*toNumber" to represent the filter.
</p>

<h4>Publisher/subscriber method as filter</h4>

<p><strong>This filter is only applicable to getter and setter.</strong> The expression
	is a string which represent the method of publisher/subscriber. For example, we can use "val" to
	as the $jQueryObject.val method, and "set" to represent proxy.set method. If a method require a
	propety name, you need to use "methodName*propertyName". For example, if we want to use
	$jQueryObject.css("color", value) method, we need to use expression "css*color". Please
	know that if publisher/subscriber is a model proxy, "get" or "set" method can also apply to
	to the model method.
</p>

<pre class="brush:javascript">
	//html is method of $view
	$div.subscribe("message", "init afterUpdate", "html");

	//css is method of $view, color is the property name
	$view.subscribe( "color", "init afterUpdate", "css*color" );
</pre>

<h4>Model helper as filter</h4>

<p>If you have function embedded in model, you can retrive it back use proxy.helper(). Here you can
	model helper as model filter use "#pathOfModelHelper".
</p>

<pre class="brush:javascript">
	$("#divSamples").subscribe("test.color", "init afterUpdate", "get #/test.setColor");
</pre>

<h3>Creating handler pipeline</h3>

<p>Subscription handler is composed with different filters. A handler can be expressed in the
	following five forms.</p>

<h4>Function</h4>

<p>This is the most simple form of handler, this is very similar to traditonal handler used
	in event binding. This form will create a handler pipeline with only one getter, which is the
	function.</p>

<pre class="brush:javascript">
	subscriber.subscribe(publisher, events, function (e) {}, options);

	//this is essentially the same as the following
	subscriber.subscribe(publisher, events, {
		get: function (e) {}
	},
	options);
</pre>

<h4>Pipeline object</h4>

<p>All forms of handler will be convert to an pipeline object. But you can use a pipeline
	object directly like the following. The filters can in one of the filter forms discussed
	ealier.</p>

<pre class="brush:javascript">
	//the filter should be in one form of these (function, common filter,
	//publisher/subscriber method, embedded function)
	subscriber.subscribe(publisher, events, {
		get: getter,
		set: setter,
		convert:converter,
		finalize: finalizer,
		initialize: initializer
	},
	options);
</pre>


<h4>String of filter keys</h4>

<p>This is special form of pipeline object. If all filters of a pipeline object
	are filter keys, we can use a string concatinating all filter keys. The keys should be
	concatinate in the order of "getter setter converter finalizer initializer disposer".
</p>

<pre class="brush:javascript">
	subscriber.subscribe(publisher, events, "getter setter converter finalizer initializer disposer", options);
	//if you have missing member you can use null in place of the misss filter. for example
	subscriber.subscribe(publisher, events, "getter setter null finalizer null disposer", options);
	//if you have don't have remaining filter, you can just leave them empty like below
	subscirber.subscriber(publisher, events, "getter setter");
</pre>

<p>Normally, you need to have at least one get filter and one set filter. But sometimes, you can
	have only one filter, and via.js can infer another filter from the type of publisher and
	subscriber.
</p>

<pre class="brush:javascript">
	via("helloApp.name").subscribe("$#txtBox", "change", "val");
	//via.js can infer "val" as "val set", because publisher is a view, and subscriber is model
	//this is equivalent to the following
	via("helloApp.name").subscribe("$#txtBox", "change", "val set");
	//
	$("divMessage").subscribe("helloApp.message", "afterUpdate", "html");
	//via.js can infer "html" as "get html", because publisher is a model, and subscriber is a view.
	//this is equivalent to the following
	$("divMessage").subscribe("helloApp.message", "afterUpdate", "get html");
</pre>

<h4>String of common pipeline name</h4>

<p>Before you can use common pipeline, you need to build a common pipeline. The syntax is,</p>

<pre class="brush:javascript">
	via.pipeline(pipelineName, pipeline);
</pre>

<p>The handler can be in one of the handler forms discussed above, such as handler function, handler
	oject (object form and string form). After you build a common, handler you can reference it
	in event subscriptions like the following.</p>

<pre class="brush:javascript">
	subscriber.subscribe(publisher, events, "*commonPipelineName", options);
</pre>

<h4>String of the path of model helper</h4>

<p>As dicussed before model helper are just model function. You can put your handler function into
	the model first, then reference it as a handler using string "#pathOfEmbeddedFunction".
</p>

<pre class="brush:javascript">
	via.set( "test", {
		updateViewColor: function (e) {
			var value = e.publisher.val();
			this.css("color", value);

		},
		color: "red"
	} );
	//reference the embedded function using "#pathOfEmbeddedFunction"
	$("#divSamples").subscribe("helloApp.color", "init afterUpdate", "#helloApp.updateViewColor");
</pre>

<p>A special form of using model helper as handler is as follow. In this case, the handler
	is the subscriber itself, so that you can leave the handler empty.</p>

<pre class="brush:javascript">
	via.extend({
		name: "",
		handleViewChange: function (e) {
			//this function is not invoked using proxy.set(),
			//this function is get filter and handler
			//"this" refer to handler object
			this.set("..name", e.publisher.val());
		}
	});

	via("handleViewChange").subscribe("$#txtName", "change", "#handleViewChange");

	//Because the handler is same as subscriber, we can leave the handler empty, like this
	via("handleViewChange").subscribe("$#txtName", "change");
</pre>

<p>Next I will talk about <a href="Declarative.html">declarative subscriptions</a></p>
</div>
</body>
</html>
