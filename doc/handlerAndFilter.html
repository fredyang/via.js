<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
	"http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
	<title>Handler pipeline and filters</title>
	<link href="../demo/css/oocss.css" rel='stylesheet'/>
	<link rel="stylesheet" type="text/css" href="introduction.css" media="all">
	<link href='../demo/SyntaxHighlighter/styles/shCore.css' rel='stylesheet'/>
	<link href='../demo/SyntaxHighlighter/styles/shThemeDefault.css' rel='stylesheet'/>
	<script src='../demo/SyntaxHighlighter/scripts/XRegExp.js'></script>
	<script src='../demo/SyntaxHighlighter/scripts/shCore.js'></script>
	<script src='../demo/SyntaxHighlighter/scripts/shBrushJScript.js'></script>
	<script src='../demo/SyntaxHighlighter/scripts/shBrushXml.js'></script>
	<script src='../demo/SyntaxHighlighter/scripts/shBrushCss.js'></script>
	<script src='analytic.js'></script>
	<script language="javascript" type="text/javascript">
		SyntaxHighlighter.defaults.gutter = false;
		SyntaxHighlighter.defaults.toolbar = false;
		SyntaxHighlighter.config.bloggerMode = true;
		SyntaxHighlighter.all();
	</script>
</head>
<body>
<div class="page oldSchool">
<h2>Handler pipleline and filters</h2>

<p>Handler is where the work is done. As we have changed event binding to event subscription,
	we also need the way we write handler. The good news is that you old handlers probabaly continue
	to work without change or with a very small change. Let's revisit the handler in "hello world"
	example.
</p>

<pre class="brush:javascript">
	//model "helloApp.name" subscribe an event of text box "txtName"
	via( "helloApp.name" ).subscribe( "$#txtName", "change", function( e ) {
	    this.set( e.publisher.val() );
	} );
	//view #divMessage subscribe an event of model "test.message"
	$( "#divMessage" ).subscribe( "helloApp.message", "afterUpdate", function( e ) {
	    this.html( e.publisher.get() );
	} );
</pre>

<p>In jQuery event handler, "this" variable refer to e.target. In via.js handler, "this" is
	subscriber. If the event is subscribed by a model, then the subscriber is a proxy. If the event
	is subscribed by a view, then the subscriber is a jQuery object of the view.
</p>

<h3>Event arguement of model event and view event</h3>

<p>
	Although the subscriptions of of model event and view event are both supported in via.js, but
	the underlining implementations are still different. via.js try to normalize the behavior of
	these two event implementation by making the event arguement the same. The following chart list
	the member of event arguement in model event handler and view event handler. The highlighted
	parts are the shared members. The other properties are specific to model event or view event.
</p>

<div class="data simpleTable">
	<table>
		<col style="width:220px">
		<col style="width:auto;">
		<col style="width:220px">
		<tr>
			<td>Event argument members<br/>
			</td>
			<td>model event argument</td>
			<td>view event argument</td>
		</tr>
		<tr>
			<td>instanceof</td>
			<td>via.Event</td>
			<td>jQuery.Event</td>
		</tr>
		<tr class="commonFeature">
			<td>publisher</td>
			<td>
				a model proxy
			</td>
			<td>augmented by via.js $(e.currentTarget)</td>
		</tr>
		<tr class="commonFeature">
			<td>originalPublisher</td>
			<td>
				a model proxy
			</td>
			<td>augmented by via.js $(e.target)</td>
		</tr>
		<tr class="commonFeature">
			<td>type</td>
			<td>
				support by via.js
			</td>
			<td>
				support by jQuery.Event
			</td>

		</tr>

		<tr class="commonFeature">
			<td>stopPropagation()</td>
			<td>
				support by via.js
			</td>
			<td>support by jQuery.Event</td>
		</tr>
		<tr class="commonFeature">
			<td>stopImmediatePropagation()</td>
			<td>
				support by via.js
			</td>
			<td>support by jQuery.Event</td>
		</tr>
		<tr>
			<td>proposed</td>
			<td>
				availabe in beforCreate, beforeUpdate event
			</td>
			<td>n/a</td>
		</tr>
		<tr>
			<td>removed</td>
			<td>
				availabe in afterDel, afterUpdate event
			</td>
			<td>n/a</td>
		</tr>
		<tr>
			<td>level</td>
			<td>
				support, a number show the level from current model to the original model
			</td>
			<td>n/a</td>
		</tr>
		<tr>
			<td>stopCascade()</td>
			<td>
				support, when called the event will not be broadCast to dependent property
			</td>
			<td>n/a</td>
		</tr>
		<tr>
			<td>error()</td>
			<td>
				support, when called in beforeUpdate, beforeCreate event handler, will abort
				update, create operations
			</td>
			<td>n/a</td>
		</tr>
		<tr>
			<td>isDependent()</td>
			<td>
				support, true if publisher model is not the ascendent of original publisher
			</td>
			<td>n/a</td>
		</tr>
		<tr>
			<td>Other jQuery Event propeteries such as target, related target, pageX, pageY, ...
			</td>
			<td>n/a</td>
			<td>support by jQuery.Event</td>
		</tr>
	</table>
</div>


<h3>Reusability</h3>

<p>Previously, I have said that the change from event binding to event subscriptions make event
	handler reusable. When there is no extenral dependencies in a function, the function is
	stateless and reusable. If we can keep our handler stateless, they will be also usable.
	In lots of case (not all the case), we can use stateless handler, just like the two handler
	above. (There are two local varible, "this" and "e".)
</p>

<h3>Composibility</h3>

<p>
	In viajs the work that an subscription handler need to finishe is very small and very
	predictable. Most of the work can be split into the following three tasks.
</p>

<ol class="simpleList">
	<li>Get the value from the publisher (Getter)</li>
	<li>Convert the value of previous step into an other value (Converter)</li>
	<li>Update subscriber with the value of previous step (Setter)</li>
</ol>

<p>We can build a handler by composing these tasks together. This is actually a pattern named<a
	href="http://www.eaipatterns.com/PipesAndFilters.html">"Pipes and Filters"</a>. Because
	publisher and subscriber are both local variable, and there is no other external dependencies,
	this make the filter also very reusable. Now let's talk about filter first, and later
	we will use filter to compose a handler.
</p>

<h3>Handler Pipeline</h3>

<p>Besides the above three tasks, via.js add two additional tasks. Handler pipeline is made of four
	filters(<strong>getter, setter, converter, finalizer</strong> ), the only required filter in
	these 4 filters is <strong>getter</strong>. These four filter executed in the context of
	subscriber, "this" is the subscriber.

	Another filter (<strong>initializer</strong>) are used during event subscription is created.
	This filter is executed in the context of global object. "this" is the global object.

	Here is how handler pipeline works.
</p>

<ol class="simpleList">
	<li>
		The handler pipleline start off with Getter. It use getter get the value from publisher and
		save it
		to current value. But you can also combine all the logic in a this filter, so that there is
		not need in other filter. You should do if the logic can not be composed by existing filter.
		Pipeline check whether a current value is a promise, if it is promise wait for the promise
		to resolve a value and save back the current value, then continue the next step, otherwise
		continue the next step.
	</li>
	<li>Pipleline check whether there is a converter. If there is, convert the current value, and
		save it back the current value.
	</li>
	<li>
		If the current value is undefined, pipeline stop. If the current value is a promise,
		wait for the promise resolve a value, then continue next step, other wise continue next
		step.
	</li>
	<li>
		Pipeline check whether there is a setter. If there is a setter, pipeline pass current value
		into setter and run it.
	</li>
	<li>
		Pipline check whether there is finalizer. If there is a finalizer, pipeline pass current
		value into setter and run it.
	</li>
</ol>

<p>Promise is object introduce in jQuery since 1.5, the support of promise in pipeline is a very
	powerful feature. We will talk about its usage.</p>

<h3>Filters</h3>


<p> Each filter can be used in one of four forms.
</p>

<ol class="simpleList">
	<li>function filter</li>
	<li>common filter</li>
	<li>publisher method or subscriber method</li>
	<li>model helper</li>
</ol>

<h4>Function filter</h4>

<p>Function is the native form of filter, all forms of filter will be converted to filter
	function.</p>

<ol class="simpleList">
	<li>getter (required, get the value of publisher or do all the work of a handler)
		<pre class="brush:javascript">
			function get(e) {
				//you can do all your work in the filter
				//and return undefined
				//or
				//get the value from e.publisher
				//return a value so that the next filter can contine the processing
			}
		</pre>
	</li>
	<li>converter (optional, convert the value returned from getter)
	<pre class="brush:javascript">
		function convert(value, e) {
			//return a new value by converting the value paramter
			// or return a promise which will resolve a converted value.
		}
	</pre>
	</li>

	<li>setter (optional, update subscriber with the value returned from converter)
	<pre class="brush:javascript">
		function set(value, e) {
			//set this
		}
	</pre>
		<p>In via.js, one creative usage of setter is to append the rendered markup into DOM
			element.</p>
	</li>
	<li>
		finalizer (optional, action will perform on the side effect that setter has created).
		<pre class="brush:javascript">
			function finalize(value, e) {
				//value is value which is passed into set filter
			}
		</pre>
		<p>
			In via.js, one of the usage of finalizer is used to parse the
			markup appended into DOM to build declarative subscriptions.
		</p>
	</li>
	<li>initializer(optional, it is called during subscription is created)
		<pre class="brush:javascript">
			function initialize ( publisher, subscriber, handlerObject, options ) {
				//publisher, subscribe are either jQuery object or model proxy
				//handlerObject is the handlerObject being build
				//options is the options that passed into
				//subscriber.subscribe(publisher, events, handler, options)
			}
		</pre>
		<p>
			It is useful when create a customized copy of reusable handlers, and wrapping
			and third party widget.
		</p>
	</li>
</ol>

<h4>Common filter</h4>

<p>Common filters are the filters which can be reused in a handler. To create common filter we
	can use the following code.</p>

<pre class="brush:javascript">
	via.filters.getters.mygetter = function (e) {};
	via.filters.converters.myconverter = function( value ) {};
	via.filters.setters.mysetter = function (value, e) {};
	via.filters.finalizers.myfinalizer = function (value, e) {};
	via.filters.initializers.myinitializer = function (publisher, subscriber, handlerObject, options) {};
	//use "*filterName" to reference the filter.
</pre>

<p>
	A common filter expression is a string. For the above common converter, we can use string
	"*toNumber" to represent the filter.
</p>

<h4>Publisher/subscriber method as filter</h4>

<p><strong>This filter is only applicable to getter and setter.</strong> The expression
	is a string which represent the method of publisher/subscriber. For example, we can use "val" to
	as the $jQueryObject.val method, and "set" to represent proxy.set method. If a method require a
	propety name, you need to use "methodName*propertyName". For example, if we want to use
	$jQueryObject.css("color", value) method, we need to use expression "css*color". Please
	know that if publisher/subscriber is a model proxy, "get" or "set" method can also apply to
	to the model method.
</p>

<pre class="brush:javascript">
	$view.subscribe( "color", "init afterUpdate", "css*color" );
</pre>

<h4>Model helper as filter</h4>

<p>If you have function embedded in model, you can retrive it back use proxy.helper(). Here you can
	model helper as model filter use "#pathOfModelHelper".
</p>


<h3>Creating handler pipeline</h3>

<p>Subscription handler is composed with different filters. A handler can be expressed in four
	forms.</p>

<h4>Handler in function form</h4>

<p>This is the most simple form of handler, this is very similar to traditonal handler used
	in event binding. This form will create a handler pipeline with only one getter, which is the
	function.</p>

<pre class="brush:javascript">
	subscriber.subscribe(publisher, events, function (e) {}, options);

	//this is essentially the same as the following
	subscriber.subscribe(publisher, events, {
		get: function (e) {}
	},
	options);
</pre>

<h4>Handler in the form of pipeline object</h4>

<p>All forms of handler will be convert to an pipeline object. But you can use a pipeline
	object directly like the following. The filters can in one of the filter forms discussed
	ealier.</p>

<pre class="brush:javascript">
	//the filter should be in one form of these (function, common filter,
	//publisher/subscriber method, embedded function)
	subscriber.subscribe(publisher, events, {
		get: getter,
		set: setter,
		convert:converter,
		finalize: finalizer,
		initialize: initializer
	},
	options);
</pre>


<h4>Handler in form of string of filter keys</h4>

<p>This is special form of pipeline object. If all filters of a pipeline object
	are filter keys, we can use a string concatinating all filter keys. The keys should be
	concatinate in the order of "getter setter converter finalizer initializer disposer".
</p>

<pre class="brush:javascript">
	subscriber.subscribe(publisher, events, "getter setter converter finalizer initializer disposer", options);
	//if you have missing member you can use null in place of the misss filter. for example
	subscriber.subscribe(publisher, events, "getter setter null finalizer null disposer", options);
	//if you have don't have remaining filter, you can just leave them empty like below
	subscirber.subscriber(publisher, events, "getter setter");
</pre>

<p>Normally, you need to have at least one get filter and one set filter. But sometimes, you can
	have only one filter, and via.js can infer another filter from the type of publisher and
	subscriber.
</p>

<pre class="brush:javascript">
	via("helloApp.name").subscribe("$#txtBox", "change", "val");
	//via.js can infer "val" as "val set", because publisher is a view, and subscriber is model
	//this is equivalent to the following
	via("helloApp.name").subscribe("$#txtBox", "change", "val set");
	//
	$("divMessage").subscribe("helloApp.message", "afterUpdate", "html");
	//via.js can infer "html" as "get html", because publisher is a model, and subscriber is a view.
	//this is equivalent to the following
	$("divMessage").subscribe("helloApp.message", "afterUpdate", "get html");
</pre>

<h4>Common handler</h4>

<p>Before you can use common handler, you need to build a common handlers. The syntax is,</p>

<pre class="brush:javascript">
	via.handlers(commonHandlerName, handler);
</pre>

<p>The handler can be in one of the handler forms discussed above, such as handler function, handler
	oject (object form and string form). After you build a common, handler you can reference it
	in event subscriptions like the following.</p>

<pre class="brush:javascript">
	subscriber.subscribe(publisher, events, "*commonHandlerName", options);
</pre>

<h4>Model helper as handler</h4>

<p>As dicussed before model helper are just model function. You can put your handler function into
	the model first, then reference it as a handler using string "#pathOfEmbeddedFunction".
</p>

<pre class="brush:javascript">
	via.set( "test", {
		updateViewColor: function (e) {
			var value = e.publisher.val();
			this.css("color", value);

		},
		color: "red"
	} );
	//reference the embedded function using "#pathOfEmbeddedFunction"
	$("#divSamples").subscribe("helloApp.color", "init afterUpdate", "#helloApp.updateViewColor");
</pre>

<p>A special form of using model helper as handler is as follow. In this case, the handler
	is the subscriber itself, so that you can leave the handler empty.</p>

<pre class="brush:javascript">
	via.extend({
		name: "",
		handleViewChange: function (e) {
			//this function is not invoked using proxy.set(),
			//this function is get filter and handler
			//"this" refer to handler object
			this.set("..name", e.publisher.val());
		}
	});

	via("handleViewChange").subscribe("$#txtName", "change", "#handleViewChange");

	//Because the handler is same as subscriber, we can leave the handler empty, like this
	via("handleViewChange").subscribe("$#txtName", "change");
</pre>

<p>Next I will talk about <a href="Declarative.html">declarative subscriptions</a></p>
</div>
</body>
</html>
