<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
	"http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
	<title>Hello world, via.js - Model</title>
	<link href="../demo/css/oocss.css" rel='stylesheet'/>
	<link rel="stylesheet" type="text/css" href="introduction.css" media="all">
	<link href='../demo/SyntaxHighlighter/styles/shCore.css' rel='stylesheet'/>
	<link href='../demo/SyntaxHighlighter/styles/shThemeDefault.css' rel='stylesheet'/>
	<script src='../demo/SyntaxHighlighter/scripts/XRegExp.js'></script>
	<script src='../demo/SyntaxHighlighter/scripts/shCore.js'></script>
	<script src='../demo/SyntaxHighlighter/scripts/shBrushJScript.js'></script>
	<script src='../demo/SyntaxHighlighter/scripts/shBrushXml.js'></script>
	<script src='../demo/SyntaxHighlighter/scripts/shBrushCss.js'></script>
	<script src='analytic.js'></script>
	<script language="javascript" type="text/javascript">
		SyntaxHighlighter.defaults.gutter = false;
		SyntaxHighlighter.defaults.toolbar = false;
		SyntaxHighlighter.config.bloggerMode = true;
		SyntaxHighlighter.all();
	</script>
</head>
<body>
<div class="page oldSchool">

<h2>Building large scale client side application.</h2>

<p>A client side application is build from smaller modules, which are also applications
	by themself. We can use the <strong><a
		href="http://en.wikipedia.org/wiki/Composite_pattern">
		composite pattern </a></strong> to build arbitrary complex application by composing smaller
	applications. To do that we need to solve two problems here.
</p>

<ol class="simpleList">
	<li>How to package unit application</li>
	<li>How to composing unit application into larger one</li>
</ol>
<p>
	Let's focus on the first problem. The hello world application is smaller enough to be called
	unit application. From the perspective of via.js, an application consist of only view and model.
	We have discussed how to build model, in the following we will talk about using template to
	built
	a view.
</p>

<h2>Template</h2>

<h3>Register template engines</h3>

<p>There are plenty client side JavaScript template engines out there.
	Instead of reinventing a new template engine, via.js let user plugin their favorite template
	engines. However, different template engines have their own philosophy, and work
	some more or less differently. Via.js tries to provide a common interface so that it does not
	depends on the implementation of different engines. In order to use a template engine,
	we need to plug it in by implementing the interface like below.
</p>

<pre class="brush:javascript">
via.template.engines( "myEngine", {
	//must implement, return jQuery dom objects or just markup in string
	render: function( templateId, data, context ) { },

	//optional, required only if you need to dynamically to load template externally
	compile: function( templateId, source ) { },

	//optional, required only if you need to dynamically to load template externally
	isTemplateLoaded: function( templateId ) { //return true or false }
});
</pre>

<p>
	The render method is the only required method. The other two methods are optional, we'll talk
	about them later. By default, if you register a new
	engine like above, the engine became the default engine. But don't want to the registered engine
	to be the defualt engine you can specify the last last parameter as true,
</p>

<pre class="brush:javascript">
	via.template.engines("myEngine", engine,  true /* notDefaultEngine */);
</pre>

<p>If you want to change default engine to another engine you can use the following</p>

<pre class="brush:javascript">
	via.template.defaultEngine = "anotherEngine";
</pre>

<p>The context passed into the engine.render is like the following.</p>
<pre class="brush:javascript">
	context = {
		modelPath: e.publisher.path,
		e: e,
		get: function( /*subPath*/ ) {
			return e.publisher.get.apply( e.publisher, slice.call( arguments ) );
		}
	};
</pre>
<p>This object allow you to access the model in your template in case you need it.</p>

<h3>Building template handler</h3>

<!--If a view subscribe an event of model, when model
	event happens, view update itself by using a handler.
	-->
<p>Now template engine is ready, and data (model) is also ready, we want to generate view. This can
	be done by using template handler. Template handler is same as other handler which is composed
	by a
	series of filters, such as getter, converter, and setter, and finalizer. What is special is
	that,
	we use a template converter which convert the data from getter into markup, and markup will be
	passed along to setter. There are two built-in template handler in via.js, below is the
	definitions.
</p>

<pre class="brush:javascript">
	var renderInside = {
		initialize: "*buildTemplateOptions",
		get: "get", //extensible
		convert: "*template",
		set: "html", //extensible
		finalize: "*importSubs"
	};

	var render = {
		initialize: "*buildTemplateOptions",
		get: "get", //extensible
		convert: "*template",
		set: "replaceWith", //extensible
		finalize: "*importSubs"
	};
</pre>

<p>The initializer "*buildTemplateOptions" is used to build template id and so on. The finalizer
	"*importSubs" is used to import the declarative subscriptions embedded in the output markup. If
	the built-in template handler does not works out for you, you can easily compose a new template
	handler
	like using the above code. Or you can use via.buildTemplateHandler, which is even easier.
	The buildTemplateHandler method return a constomized copy of "renderInside" handler.
</p>

<pre class="brush:javascript">
	var myNewTemplateHandler = via.template.buildTemplateHandler(myGetter, mySetter);
	//or
	var myNewTemplateHandler = via.template.buildTemplateHandler({
		get: myGetter, //optional
		set: mySetter, //optional
		finalize: myFinalizer //optional
	});
</pre>

<h3>Use template handler programatically</h3>

<p>Let's use template handler to refactor the hello world app.Firstly,
	We will do this programatically, and later declaratively. In the following we will use <a
		href="https://github.com/BorisMoore/jsrender/">jsrender</a> as template engine, you can
	find the registration code of the template in the source.</p>

<pre class="brush:html">
	&lt;div id="appContainer"&gt; &lt;/div&gt;

	&lt;script type="jsrender" id="hello"&gt;
		&lt;div&gt;
			&lt;label&gt;{{:prompt}}: &lt;input type="text" class="name"/&gt;&lt;/label&gt;
			&lt;div class="divMessage"/&gt;
		&lt;/div&gt;
	&lt;/script&gt;

</pre>

<pre class="brush:javascript">
//build model
via.set( "helloApp", {
	prompt: "Please input your name:",
	name: "",
	message: function() {
		var name = this.get( "name" );
		return name ? "hello, " + name : "";
	}
} );
</pre>

<pre class="brush:javascript">
	var templateId = "hello";
	//build subscriptions
	$( "#appContainer" ).subscribe( "helloApp", "init", via.template.buildTemplateHandler( {

		//after the markup is merged with page, finalizer programatically
		//build the subscriptions
		finalize: function( value, e ) {

			//"name" model subscribe the change of textbox view
			e.publisher.cd( "name" ).subscribe(
				value.findAll( ".name" ),
				"change",
				"val"
			);

			//label view subscribe the change of "message" model
			value.findAll( ".divMessage" ).subscribe(
				e.publisher.cd( "message" ).path,
				"afterUpdate",
				"html"
			);
		}
	} ), templateId);
</pre>

<p>First we define a model, we let the body subscribe a special event "init" of model with a
	customized "*renderInside" template handler. The handler's finalizer programatically build
	the subscriptions for the generated markup. In via.js, there is a shortcut method to do the same
	job.
</p>

<pre class="brush:javascript">
	$( "#appContainer" ).renderInside(

		"hello", //template id

		"helloAppModel",	//model path

		//finalizer
		function( value, e ) {
			//"name" model subscribe the change of textbox view
			e.publisher.cd( "name" ).subscribe(
				value.findAll( ".name" ),
				"change",
				"val"
			);

			//label view subscribe the change of "message" model
			value.findAll( ".divMessage" ).subscribe(
				e.publisher.cd( "message" ).path,
				"afterUpdate",
				"html"
			);
		}
	);
</pre>

<h3>Use template handler declaratively</h3>

<p>Now let's use declarative subscriptions and template to build the hello app again.
	And we attach data-sub attribute to container and the elements inside the template, we remove
	the
	all the subscription code. This looks cleaner.
</p>

<pre class="brush:html">
	&lt;div data-sub="`forObject:helloApp|hello"&gt;
	&lt;/div&gt;

	&lt;script type="tmpl" id="hello"&gt;
		&lt;div data-sub="@ns:helloApp"&gt;
			&lt;label&gt;{{:prompt}}: &lt;input type="text" data-sub="`val:name"/&gt;&lt;/label&gt;
			&lt;div data-sub="`html:message"/&gt;
		&lt;/div&gt;
	&lt;/script&gt;
</pre>

<p>We can see that declarative subscriptions inside the template will aslo work this is because of
	finalizer "*importSubs". We can have nested template "infinitive" deep without writing any code
	to build subscriptions in side of nested template. This is a very cool feature. The benefit of
	declarative subscriptions in template is more obvious.
</p>

<p>In this example, the template is placed in a script tag, if the template is only used by the
	container
	we can place the template inside the container, we call this inline template.</p>

<pre class="brush:javascript">
	&lt;div data-sub="`forObject:helloApp"&gt;
		&lt;div data-sub="@ns:helloApp"&gt;
			&lt;label&gt;{{:prompt}}: &lt;input type="text" data-sub="`val:name"/&gt;&lt;/label&gt;
			&lt;div data-sub="`html:message"/&gt;
		&lt;/div&gt;
	&lt;/div&gt;
</pre>

<p>However, inline template has some limitations. First the template can not be reused, second nest
	inline template inside inline template.
</p>


<h3>More about template options</h3>

<p>So far, we have been specify template id as options like one of the following</p>

<pre class="brush:javascript">
	$view.subscribe(modelPath, "init", templateHandler, templateOptions);
	//
	$view.renderInside(modelPath, templateOption, finalizer);
	//
	data-sub="`forObject:modelPath|tempateOptions"
</pre>

<p>But there are two additional switch (useDataSourceAsArrayItem,egnineName) you can specify in
	the template option, but they are optional.
</p>

<pre class="brush:javascript">
	//the full templateOptions
	templateOptions = "templateId,useDataSourceAsArrayItem,engineName"
	//e.g
	templateOptions = "templateId"; //useDataSourceAsArrayItem=false, engineName="default"
	templateOptions = "templateId,true"; //useDataSourceAsArrayItem=true, engineName="default"
	templateOptions = "templateId,,myEngine"; //useDataSourceAsArrayItem=false
	templateOptions = "templateId,true,myEngine";
</pre>

<p>By default "useDataSourceAsArrayItem" is false, via.js passed to data from getter to the
	engine.render method as-is. If you want to pass [data] to engine.render method, you can specify
	"useDataSourceAsArrayItem" as "true". This options is useful for some scenario.
</p>

<p>
	"engineName" by default is the value of via.template.defaultEngine. In case you want to use two
	or more engines at the same time (although it is rare), you want need to specify the engine name
	for non-default engine. The following code how to use jsrender and mustache engine at the same
	time.
</p>

<pre class="brush:html">
	&lt;div data-sub="`forObject:greeting|greetingTemplate,,mustache"&gt;&lt;/div&gt;

	&lt;!-- jsrender is default engine here, no need to specify the template name --&gt;
	&lt;div data-sub="`forObject:person|personTemplate"&gt;&lt;/div&gt;

	&lt;script id="greetingTemplate" type="mustache"&gt;
		&lt;h2&gt;{{message}}&lt;/h2&gt;
	&lt;/script&gt;

	&lt;script id="personTemplate" type="jsrender"&gt;
		&lt;h2&gt;{{:name}}&lt;/h2&gt;
	&lt;/script&gt;
</pre>

<pre class="brush:javascript">
	via.extend( {
		greeting: {
			message: "hello"
		},
		person: {
			name: "John"
		}
	} );
</pre>

<h3>Dynamic template loading</h3>

<p>Traditionally, the template source is embedded in the page markup. However, if we don't know
	what view need to generated in advance, we might preload too many templates into the page.
	To solve the probem, we can seperate templates into different groups, and put each group of
	templates into an external file. When template converter tries render a template, if the
	template is not loaded, it will load the template first, after it is loaded, then continue the
	process. In this case the template converter return a <strong>promise</strong>.
	Below is the modified implementation of template converter.
</p>

<pre class="brush:javascript">
	//this is called by converters.renderTemplate
	function renderTemplate ( templateId, dataSource, renderContext, engineName ) {

		var engine = getTemplateEngine( engineName );
		templateId = $.trim( templateId );

		//The implementation of engine.isTemplateLoaded is optional
		if (!engine.isTemplateLoaded || engine.isTemplateLoaded( templateId )) {

			return engine.render( templateId, dataSource, renderContext );

		} else {

			var defer = $.Deferred();
			//dynamically load the template by id using ajax, web socket or other means
			via.template.load( templateId ).done( function() {
				var content = engine.render( templateId, dataSource, renderContext );
				var rtn = $( content );
				defer.resolve( rtn.selector || !rtn.length ? content : rtn );
			} );
			return defer.promise();
		}
	}

	via.filters.converters.template = function( dataSource, e ) {
		//..
		return renderTemplate(...);
	}
</pre>

<p>From the code we can understand why we need to implement <strong>engine.isTemplateLoaded</strong>
	if we want to support dynamic template loading. And we need to implement the
	<strong>via.template.load</strong> method as well. via.js provides one default implementation as
	follow. But it depends on an external library <strong>matrix.js</strong>.
</p>
<pre class="brush:javascript">
	via.template.load = function( templateId ) {
		if (typeof matrix == "undefined") {
			throw "The method via.template.load require matrix.js," +
			      "or you need override the method";
		}
		return matrix( templateId + ".template" );
	};
</pre>
<!--	so that <strong>engine.isTemplateLoaded</strong>
	returns true after template is loaded. <strong>via.template.compile</strong> delegate the work
	to <strong>engine.compile</strong> like the following, this is why you need to implement
	<strong>engine.compile</strong>.
-->
<p>
	If you don't want to reference other library, you can implement the method as long as it return
	a jQuery promise. The default implementation of via.template.load call
	<strong>via.template.compile</strong> method which delegates the work to
	to <strong>engine.compile</strong> like the following. That is why you also need to implement
	this for your favorite template engine.
</p>
<pre class="brush:javascript">
	via.template.compile = function( templateId, source, engineName ) {
		var engine = getTemplateEngine( engineName );
		return engine.compile( templateId, source );
	};
</pre>

<p>One more thing you need make sure is that , after "engine.compile(templateId, source)" is called
	"engine.isTemplateLoaded( templateId )" should return true.
</p>

<p>
	Implementing a <strong>via.template.load</strong> is quite tricky, it is suggested to use the
	default implementation which depends on matrix.js.
</p>

<p>
	To put a template to an external, We need to do the following. Suppose your template id is
	"hello"
</p>

<ol class="simpleList">
	<li>Create a file in the matrix_resource_folder\template\hello\main.html, and put your template
		source into the file
	</li>
	<li>Remove the template inside the page</li>
</ol>

<pre class="brush:html">
	&lt;!-- markup in page --&gt;
	&lt;body data-sub="`forObject:helloApp|hello"&gt;
	&lt;/body&gt;
</pre>

<pre class="brush:html">
	&lt;!-- markup in page in matrix_resource_folder\template\hello\main.html--&gt;
	&lt;script type="tmpl" id="hello"&gt;
		&lt;div data-sub="@ns:helloAppModel"&gt;
			&lt;label&gt;{{:prompt}}: &lt;input type="text" data-sub="`val:name"/&gt;&lt;/label&gt;
			&lt;div data-sub="`html:message"/&gt;
		&lt;/div&gt;
	&lt;/script&gt;
</pre>


<p>If a template is not loaded, matrix.js will map the template id in to a template file name,
	using the following mapping, then load the file and import the the template inside.</p>

<div class="data simpleTable">
	<table>
		<tr>
			<td>
				Template Id
			</td>
			<td>
				Template file Name
			</td>

		</tr>
		<tr>
			<td>
				a
			</td>
			<td>
				matrix_resource/template/a/main.html
			</td>
		</tr>
		<tr>
			<td>
				a.b, a.b.c, a.b.c.d, .., a.*
			</td>
			<td>
				matrix_resource/template/a/b.html
			</td>
		</tr>
		<tr>
			<td>
				_a, _a.b, .., _a.*
			</td>
			<td>
				matrix_resource/tempalte/_/a.html
			</td>
		</tr>

	</table>
</div>

<p>You don't necessarily put a template into a file according to this mapping, because we
	can group multiple templates into the a single template file. When matrix.js load a
	template file, it will import all the templates defined in the file. If we decide to put a
	template x into a template file y, but the template x does not map to file name y according to
	the mapping, instead template z map to file name y, we need to make sure template z is
	referenced in our application before template x is referenced. For example, we want to put
	template "a.b" into matrix_resource/a/main.html, we need to make sure template "a" is referenced
	first before "a.b".
</p>

<h3>Dynamic model loading</h3>

<p>
	We are able to put our template in external file now. But we still have our model embeded in the
	page. In order truely build a self-contained application, we need to be able to load our model
	dynamicallly. Here is what needs to be done in additional to the work mentioned in dynamic
	template loading.
</p>

<ol class="simpleList">
	<li>Use data-sub="@loadapp:helloApp" for the app container
		<pre class="brush:html">
			&lt;body data-sub="@loadapp:helloApp"&gt;&lt;/body&gt;
		</pre>

	</li>
	<li>Create matrix_resource_folder\appLoader\helloApp.js, use the following code in the file.
		<pre class="brush:javascript">
			(function() {

				return {

					load: function( appContainer, options ) {

						//build the model first
						via.set( "helloAppModel", {
							prompt: "Please input your name:",
							name: "",
							message: function() {
								var name = this.get( "name" );
								return name ? "hello, " + name : "";
							}
						} );

						//render the template inside of the
						//application container
						$( appContainer ).renderInside(
							"helloAppModel"/*modelPath*/,
							"hello" /*templateId*/
						);
					},

					unload: function() { }
				};
			})();
		</pre>
	</li>
</ol>

<h2>Ajax</h2>

<p>The handler pipleine in via.js can support asynchrounous getters and converters which return a
	promise. When a promise is returned, pipeline will "wait" for the promise to deliver a real
	value. When the real value is delivered, the pipleline will resume and continue to process next
	filter with the delivered value. In fact, handler pipeline support both getter and converter to
	be asynchrounous at the same itme. Since jQuery 1.5, $.ajax has been rewrittern to return a
	jqXHR which is a promise object. So we can just just return the jqXHR in our getter and
	converter.
</p>

<p>
	In the "hello world" example, if the message need to be fetched from a ajax service. This can be
	easily done by using a converter in the handler like the following.
</p>

<pre class="brush:html">
	&lt;!-- the div subscribe the change of model "name" using a handler with a async converter--&gt;
	&lt;div data-sub="!init after*:name|get html #..getMessage"/&gt;
</pre>
<pre class="brush:javascript">
	via.set( "test", {
      name: "",
      getMessage: function( value, e ) {
          return $.ajax( {
              url: "getMessage",
              dataType: 'json',
              data: JSON.stringify( value )
          } );
      }
  } );
</pre>

<p>A even more simple solution is to use asynchronous model function. The label
	can subscribe the change of the asynchronous model function like normal model function.
</p>
<pre class="brush:html">
	&lt;div data-sub="`html:message"/&gt;
</pre>
<pre class="brush:javascript">
	via.set( "test", {
	    name: "",
	    message: function() {
	        var name = this.get( "name" );
	        return $.ajax( {
	            url: "getMessage",
	            dataType: 'json',
	            data: JSON.stringify( name )
	        } );
	    }
	} );
</pre>

<h2>Summary</h2>

<p>
	So far, we have covered a lot about via.js. If you use jQuery a lot, you may find that
	via.js is just a library which mimic the programming experience of jQuery. Lots of designs of
	via.js are directly
	borrowed from jQuery. So what does does via.js offer?
</p>

<ol class="simpleList">
	<li>A model which can raise event</li>
	<li>A unified event subscriptions instead of event binding</li>
	<li>A handler pipleine</li>
	<li>A declarative way to use event subscriptions and other feature</li>
</ol>

<!--<div class="data simpleTable">
	<table>
		<col style="width:110px;">
		<col>
		<col>
		<tr>
			<td>Comparison</td>
			<td>jQuery</td>
			<td>via</td>
		</tr>
		<tr>
			<td>Internal Data</td>
			<td>DOM holds all nodes. It is tree of nodes</td>
			<td>A internal plain old javascript object holds all model. It is a tree of
				values
			</td>
		</tr>
		<tr>
			<td>
				Proxy Creation
			</td>
			<td>
		   <pre class="brush:javascript">
			   $(selector);
			   $("#txtFirstName");
		   </pre>
			</td>
			<td>
		   <pre class="brush:javascript">
			   via(path);
			   via("helloApp.firstName");
		   </pre>
			</td>
		</tr>
		<tr>
			<td>Proxy Access</td>
			<td>
		   <pre class="brush:javascript">
			   //get
			   $div.html();
			   //set
			   $div.html("hello");
			   //remove
			   $div.remove();
		   </pre>
			</td>
			<td>
		   <pre class="brush:javascript">
			   //get
			   firstNameProxy.get();
			   //set
			   firstNameProxy.set("John");
			   //remove
			   firstNameProxy.del();
			   //other access method
			   contactsProxy.push({ name: "John" });
		   </pre>
			</td>
		</tr>
		<tr>
			<td>Proxy Extension</td>
			<td>
		   <pre class="brush:javascript tableCode">
			   $.fn.foo = function () {
				   //implementation
			   };
			   $div.foo();
		   </pre>
			</td>
			<td>
		   <pre class="brush:javascript tableCode">
			   via.fn.foo = function(path,value)
			   {
				   //implementation
			   };
			   via("firstName").foo(path, value);
		   </pre>
			</td>
		</tr>
		<tr>
			<td>Event Subscriptions</td>
			<td>
		   <pre class="brush:javascript">
			   //$.fn.subscribe is added
			   //by via.js
			   $div.subscribe("helloApp.firstName",
				   "afterUpdate",
				   function (e) {
			   this.html(
				   e.publisher.get()
				   );
			   });
		   </pre>
			</td>
			<td>
		   <pre class="brush:javascript">
			   firstNameProxy.subscribe(
			   "$#txtBox",
			   "change",
			   function (e) {
				   this.set(
					   e.publisher.val()
				   );
			   });
		   </pre>
			</td>
		</tr>
		<tr>
			<td>Custom Event</td>
			<td>Support</td>
			<td>Support</td>
		</tr>
		<tr>
			<td>Event bubbling</td>
			<td>Support</td>
			<td>Support</td>
		</tr>
		<tr>
			<td>Stop event propogation</td>
			<td>Support</td>
			<td>Support</td>
		</tr>
	</table>
</div>-->

<h2>Beyond hello world</h2>

<p>The hello world example may be too simple, does it works in real world scenario. There are
	lots code example in the source. Please check out for yourself.</p>

</div>
</body>
</html>
