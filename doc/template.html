<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
	"http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
	<title>Template</title>
	<link href="../demo/css/oocss.css" rel='stylesheet'/>
	<link rel="stylesheet" type="text/css" href="introduction.css" media="all">
	<link href='../demo/SyntaxHighlighter/styles/shCore.css' rel='stylesheet'/>
	<link href='../demo/SyntaxHighlighter/styles/shThemeDefault.css' rel='stylesheet'/>
	<script src='../demo/SyntaxHighlighter/scripts/XRegExp.js'></script>
	<script src='../demo/SyntaxHighlighter/scripts/shCore.js'></script>
	<script src='../demo/SyntaxHighlighter/scripts/shBrushJScript.js'></script>
	<script src='../demo/SyntaxHighlighter/scripts/shBrushXml.js'></script>
	<script src='../demo/SyntaxHighlighter/scripts/shBrushCss.js'></script>
	<script src='analytic.js'></script>
	<script language="javascript" type="text/javascript">
		SyntaxHighlighter.defaults.gutter = false;
		SyntaxHighlighter.defaults.toolbar = false;
		SyntaxHighlighter.config.bloggerMode = true;
		SyntaxHighlighter.all();
	</script>
</head>
<body>
<div class="page oldSchool">


<h2>Template</h2>

<!--<p>A large scale client side application can be built from smaller application. We can use the
<strong><a href="http://en.wikipedia.org/wiki/Composite_pattern">
composite pattern </a></strong> to build arbitrary complex application by composing smaller
applications. To do that we need to solve two problems here.
</p>

<ol class="simpleList">
<li>How to package unit application</li>
<li>How to compose small application into larger one</li>
</ol>
<p>
Let's focus on the first problem. The hello world application is smaller enough to be called
unit application. From the perspective of via.js, an application consist of only view and model.
We have discussed how to build model, in the following we will talk about using template to
built a view.
</p>

-->

<p>In previous implementation of hellowold application, all the view objects are created statically.
	This is ok for small application. In large application, views are generated by template and
	data.</p>


<h3>Register template engines</h3>

<p>Via.js does not provide a template engine out of the box, this is becaue there are lots
	client side JavaScript template engines already. Instead of reinventing a new template engine,
	via.js let user register their favorite template engine by implementing an engineProxy so that
	via.js can use it.
</p>

<pre class="brush:javascript">
	var engineProxy =  {
		//must implement, return jQuery dom objects or just markup in string
		render: function( templateId, data, context ) { },

		//optional, required only if you need to load extenral template on demand
		compile: function( templateId, source ) { },

		//optional, required only if you need to load extenral template on demand
		isTemplateLoaded: function( templateId ) { //return true or false }
	};

	via.template.engineProxies( "myEngine", engineProxy);
</pre>

<p>
	The render method is the only required method. The other two methods are optional, we'll talk
	about them later. via.js support multiple template engines. By default, if you register a new
	engineProxy like above, the engine became the default engine. But don't want to the
	registered engine to be the defualt engine you can specify the last last parameter as true,
</p>

<pre class="brush:javascript">
	via.template.engineProxies("myEngine", engineProxy,  true /* notDefaultEngine */);
</pre>

<p>If you want to change default engine to another engine you can use the following.</p>

<pre class="brush:javascript">
	via.template.defaultEngine = "anotherEngineName";
</pre>

<p>The context passed into the engineProxy.render is like the following. It allow you to access
	the model in your template in case you need it.</p>

<pre class="brush:javascript">
	context = {
		modelPath: e.publisher.path,
		e: e,
		get: function( /*subPath*/ ) {
			return e.publisher.get.apply( e.publisher, slice.call( arguments ) );
		}
	};
</pre>

<p>The via.js library does not include any template engineProxy. However, in the source code
	there are three template engineProxies (jQuery tmpl, jsrender, and mustache). If your
	favorite template engine is one of them, you can use them, if not you can implement the
	registration object by referencing the source code of these three registrations. But It should
	be quite straight forward.
</p>

<h3>Template pipelines</h3>

<!--If a view subscribe an event of model, when model
	event happens, view update itself by using a handler.
	-->
<p>In via.js, views are generated by views. The only view that are generated by developer is root
	view. A view generate its child views by using subscription handler. When data is initially
	available or changed afterward, parent view will use the handler to generate its child view.
	This subscription handler is also a pipeline object. What is special for this pipeline object is
	that it has a converter filter, which convert the data output from get filter into markup, and
	the setter filter will merge it into parent view. The pipeline also have finalizer filter,
	which build declative subscription for newly created child views. There are two built-in
	template pipelines in via.js, below is the definitions.
</p>

<pre class="brush:javascript">
	var renderInside = {
		initialize: "*buildTemplateOptions",
		get: "get", //extensible
		convert: "*template",
		set: "html", //extensible
		finalize: "*importSubs" //extensible
	};

	var render = {
		initialize: "*buildTemplateOptions",
		get: "get", //extensible
		convert: "*template",
		set: "replaceWith", //extensible
		finalize: "*importSubs" //extensible
	};
</pre>

<p>The initializer "*buildTemplateOptions" is used to build template id and so on. The finalizer
	"*importSubs" is used to import the declarative subscriptions embedded in the output markup. If
	the built-in template pipeline does not works out for you, you can easily compose a new template
	pipeline like using the above code. Or you can use via.buildTemplatePipeline, which is even
	easier. The buildTemplatePipeline method return a constomized copy of "renderInside" handler.
</p>

<pre class="brush:javascript">
	var myTemplatePipleine = via.template.buildTemplatePipeline(myGetter, mySetter);
	//or
	var myTemplatePipleine = via.template.buildTemplatePipeline({
		get: myGetter, //optional
		set: mySetter, //optional
		finalize: myFinalizer //optional
	});
</pre>

<h3>Use template pipelines programatically</h3>

<p>Let's use template pipeline to refactor the hello world app. Firstly,
	We will do this programatically, and later declaratively. In the <a
		href="../demo/helloworld/13-template-programatic1.html">following</a>, we will use <a
		href="https://github.com/BorisMoore/jsrender/">jsrender</a> as template engine.</p>

<pre class="brush:html">
	&lt;div id="appContainer"&gt; &lt;/div&gt;

	&lt;script type="jsrender" id="hello"&gt;
		&lt;div&gt;
			&lt;label&gt;{{:prompt}}: &lt;input type="text" class="name"/&gt;&lt;/label&gt;
			&lt;div class="divMessage"/&gt;
		&lt;/div&gt;
	&lt;/script&gt;

</pre>

<pre class="brush:javascript">
//build model
via.set( "helloApp", {
	prompt: "Please input your name:",
	name: "",
	message: function() {
		var name = this.get( "name" );
		return name ? "hello, " + name : "";
	}
} );
</pre>

<pre class="brush:javascript">
	var templateId = "hello";
	//build subscriptions
	$( "#appContainer" ).subscribe( "helloApp", "init", via.template.buildTemplatePipeline( {

		//after the markup is merged with page, finalizer programatically
		//build the subscriptions
		finalize: function( value, e ) {

			//"name" model subscribe the change of textbox view
			e.publisher.cd( "name" ).subscribe(
				value.findAll( ".name" ),
				"change",
				"val"
			);

			//label view subscribe the change of "message" model
			value.findAll( ".divMessage" ).subscribe(
				e.publisher.cd( "message" ).path,
				"afterUpdate",
				"html"
			);
		}
	} ), templateId);
</pre>

<p>First we define a model, we let the body subscribe a special event "init" of model with a
	customized "*renderInside" template pipeline. The handler's finalizer programatically build
	the subscriptions for the generated markup.
</p>

<h3>Use template pipeline declaratively</h3>

<p>Now let's use declarative subscriptions and template to build the helloworld app like the <a
	href="../demo/helloworld/15-template-declarative-embedded-template.html">following</a>. And we
	attach data-sub attribute to container and the elements inside the template.
</p>

<pre class="brush:html">
	&lt;div data-sub="`for:helloApp|hello"&gt;
	&lt;/div&gt;

	&lt;script type="jsrender" id="hello"&gt;
		&lt;div data-sub="@ns:helloApp"&gt;
			&lt;label&gt;{{:prompt}}: &lt;input type="text" data-sub="`val:name"/&gt;&lt;/label&gt;
			&lt;div data-sub="`html:message"/&gt;
		&lt;/div&gt;
	&lt;/script&gt;
</pre>
<!--
<p>Here we use for class declaration to render template. There are for template class
	declaration. There are four class declaration in via.js, the difference is about when
	the view need to be re-rendered when the model change.
</p>


<div class="data simpleTable">
	<table>
		<col width="100px">
		<col width="200px">
		<col width="auto">
		<tr>
			<td>class name</td>
			<td>view will be re-rendered template when</td>
			<td>for example</td>
		</tr>
		<tr>
			<td>for</td>
			<td>never</td>
			<td></td>
		</tr>
		<tr>
			<td>forSelf</td>
			<td>when model itself is updated</td>
			<td>
				<pre class="brush:javascript">
					via.set("customer", {
						firstName: "John",
						lastName: "Doe",
					});

					&lt;div data-sub="@forSelf:customer|myTemplate"&gt;&lt;/div&gt;

					//the following update, will trigger re-render
					via.set("customer", {
						firstName: "Jane",
						lastName: "Poe"
					});
				</pre>
			</td>
		</tr>
		<tr>
			<td>forChildren</td>
			<td>when model itself or its children are updated</td>
			<td>
				<pre class="brush:javascript">
					via.set("customers", [{
						firstName: "John",
						lastName: "Doe",
					}]);

					&lt;div data-sub="@forChildren:customers|myTemplate"&gt;&lt;/div&gt;

					//the following update, will trigger re-render
					via.set("customer.0", {
						firstName: "Jane",
						lastName: "Poe"
					});
				</pre>
			</td>
		</tr>
		<tr>
			<td>forAll</td>
			<td>when model itself or its descendents are updated</td>
			<td>
				<pre class="brush:javascript">
					via.set("customers", [{
						firstName: "John",
						lastName: "Doe",
					}]);

					&lt;div data-sub="@forChildren:customers|myTemplate"&gt;&lt;/div&gt;


					//the following update, will trigger re-render
					via.set("customer.0.firstName", "Jane");
				</pre>
			</td>
		</tr>
	</table>
</div>-->


<p>The declarative subscriptions of the views generated by template is automatically created by
	finalizer "*importSubs" of the template pipeline. We can build very complex view by nesting view
	within view and wireup all the subscription without writing a single line of code. <strong>This
		is a very powerful feature, and it is exactly the benefit of declarative subscriptions in
		template</strong>.
</p>


<p>In the above example, the template is placed in a script tag inside the page, we call this kind
	template <strong>embedded template</strong>. This template can reference by id, and can be
	reused. If the template is only used by the container, we can place the template inside the
	container, we call this <strong>inline template</strong>. In the following, move the content of
	script tag into the container and remove the script tag.
</p>

<pre class="brush:javascript">
	&lt;div data-sub="`for:helloApp"&gt;
		&lt;div data-sub="@ns:helloApp"&gt;
			&lt;label&gt;{{:prompt}}: &lt;input type="text" data-sub="`val:name"/&gt;&lt;/label&gt;
			&lt;div data-sub="`html:message"/&gt;
		&lt;/div&gt;
	&lt;/div&gt;
</pre>

<p>Inline template works in simple scenario. However, it has two limitations. First
	the template can not be reused, second nest inline template inside inline template is
	unsupported by most of the template engine.
</p>


<h3>More about template options</h3>

<p>So far, we have been specify template id as options like one of the following</p>

<pre class="brush:javascript">
	$view.subscribe(modelPath, "init", templateHandler, templateId /*options*/);
	//
	data-sub="`for:modelPath|templateId"
</pre>

<p>But there are two additional switch (useDataSourceAsArrayItem,egnineName) you can specify in
	the template option, but they are optional.
</p>

<pre class="brush:javascript">
	//the full templateOptions
	templateOptions = "templateId,useDataSourceAsArrayItem,engineName"
	//e.g
	templateOptions = "templateId"; //useDataSourceAsArrayItem=false, engineName="default"
	templateOptions = "templateId,true"; //useDataSourceAsArrayItem=true, engineName="default"
	templateOptions = "templateId,,myEngine"; //useDataSourceAsArrayItem=false
	templateOptions = "templateId,true,myEngine";
</pre>

<p>By default "useDataSourceAsArrayItem" is false, via.js passed to data from getter to the
	engineProxy.render method as-is. If you want to pass [data] to engineProxy.render method, you
	can specify
	"useDataSourceAsArrayItem" as "true". This options is useful for some scenario.
</p>

<p>
	"engineName" by default is the value of via.template.defaultEngine. In case you want to use two
	or more engines at the same time (although it is rare), you want need to specify the engine name
	for non-default engine. The following code how to use jsrender and mustache engine at the same
	time.
</p>

<pre class="brush:html">
	&lt;div data-sub="`for:greeting|greetingTemplate,,mustache"&gt;&lt;/div&gt;

	&lt;!-- jsrender is default engine here, no need to specify the template name --&gt;
	&lt;div data-sub="`for:person|personTemplate"&gt;&lt;/div&gt;

	&lt;script id="greetingTemplate" type="mustache"&gt;
		&lt;h2&gt;{{message}}&lt;/h2&gt;
	&lt;/script&gt;

	&lt;script id="personTemplate" type="jsrender"&gt;
		&lt;h2&gt;{{:name}}&lt;/h2&gt;
	&lt;/script&gt;
</pre>

<pre class="brush:javascript">
	via.extend( {
		greeting: {
			message: "hello"
		},
		person: {
			name: "John"
		}
	} );
</pre>

<h3>Loading external template on demand</h3>

<p>Traditionally, the template source is embedded in the page markup. However, if we don't know
	what view need to generated in advance, we might preload too many templates to browser.
	To solve the probem, we can seperate templates into different groups, and put each group of
	templates into an external file. When template converter tries render a template, if the
	template is not loaded, converter will know that it is an external template, and try
	to the external template first, after it is loaded, then continue the remaining
	jobs. In this case the template converter return a <strong>promise</strong>. In order to support
	this scenario, we need to implement the following.
	<!--Below is the modified implementation of template converter.-->
</p>

<!--<pre class="brush:javascript">
	//this is called by converters.renderTemplate
	function renderTemplate ( templateId, dataSource, renderContext, engineName ) {

		var engine = getTemplateEngine( engineName );
		templateId = $.trim( templateId );

		//The implementation of engineProxy.isTemplateLoaded is optional
		if (!engineProxy.isTemplateLoaded || engineProxy.isTemplateLoaded( templateId )) {

			return engineProxy.render( templateId, dataSource, renderContext );

		} else {

			var defer = $.Deferred();
			//dynamically load the template by id using ajax, web socket or other means
			via.template.load( templateId ).done( function() {
				var content = engineProxy.render( templateId, dataSource, renderContext );
				var rtn = $( content );
				defer.resolve( rtn.selector || !rtn.length ? content : rtn );
			} );
			return defer.promise();
		}
	}

	via.filters.converters.template = function( dataSource, e ) {
		//..
		return renderTemplate(...);
	}
</pre>-->

<ol class="simpleList">
	<li>via.template.load(templateId) --> return a promise object</li>
	<li>engineProxy.isTemplateLoaded(templateId) --> return true or false</li>
	<li>engineProxy.compile( templateId, source )</li>
</ol>

<p>via.js already via.template.load. But it depends on an external library
	<a href="https://github.com/fredyang/matrix.js">matrix.js</a>. If you don't want to reference
	other library, you can implement the method as long as it return
	a jQuery promise.</p>
<pre class="brush:javascript">
	via.template.load = function( templateId ) {
		if (typeof matrix == "undefined") {
			throw "The method via.template.load require matrix.js," +
			      "or you need override the method";
		}
		return matrix( templateId + ".template" );
	};
</pre>
<!--	so that <strong>engineProxy.isTemplateLoaded</strong>
	returns true after template is loaded. <strong>via.template.compile</strong> delegate the work
	to <strong>engineProxy.compile</strong> like the following, this is why you need to implement
	<strong>engineProxy.compile</strong>.
-->

<!--
<p>
	If you don't want to reference other library, you can implement the method as long as it return
	a jQuery promise. The default implementation of via.template.load call
	<strong>via.template.compile</strong> method which delegates the work to
	to <strong>engineProxy.compile</strong> like the following. That is why you also need to
	implement this for your favorite template engine.
</p>
<pre class="brush:javascript">
	via.template.compile = function( templateId, source, engineName ) {
		var engineProxy = getTemplateEngine( engineName );
		return engineProxy.compile( templateId, source );
	};
</pre>

<p>One more thing you need make sure is that , after "engineProxy.compile(templateId, source)" is
	called "engineProxy.isTemplateLoaded( templateId )" should return true.
</p>

<p>
	Implementing a <strong>via.template.load</strong> is quite tricky, it is suggested to use the
	default implementation which depends on matrix.js.
</p>
-->

<p>
	To put a template to an external, We need to do the following. Suppose your template id is
	"hello"
</p>

<ol class="simpleList">
	<li>Create a file in the matrix_resource_folder\template\hello\main.html, and put your template
		source into the file
	</li>
	<li>Remove the template inside the page</li>
</ol>

<pre class="brush:html">
	&lt;!-- markup in page --&gt;
	&lt;body data-sub="`for:helloApp|hello"&gt;
	&lt;/body&gt;
</pre>

<pre class="brush:html">
	&lt;!-- markup in page in matrix_resource_folder\template\hello\main.html--&gt;
	&lt;script type="tmpl" id="hello"&gt;
		&lt;div data-sub="@ns:helloAppModel"&gt;
			&lt;label&gt;{{:prompt}}: &lt;input type="text" data-sub="`val:name"/&gt;&lt;/label&gt;
			&lt;div data-sub="`html:message"/&gt;
		&lt;/div&gt;
	&lt;/script&gt;
</pre>


<p>If a template is not loaded, matrix.js will map the template id in to a template file name,
	using the following mapping, then load the file and import the the template inside.</p>

<div class="data simpleTable">
	<table>
		<tr>
			<td>
				Template Id
			</td>
			<td>
				Template file Name
			</td>

		</tr>
		<tr>
			<td>
				a
			</td>
			<td>
				matrix_resource/template/a/main.html
			</td>
		</tr>
		<tr>
			<td>
				a.b, &nbsp;&nbsp; a.b.c, &nbsp;&nbsp; a.b.c.d, &nbsp;&nbsp; a.b.c.d.e
			</td>
			<td>
				matrix_resource/template/a/b.html
			</td>
		</tr>
		<tr>
			<td>
				_a, &nbsp;&nbsp; _a.b, &nbsp;&nbsp; _a.b.c, &nbsp;&nbsp; _a.b.c.e
			</td>
			<td>
				matrix_resource/tempalte/_/a.html
			</td>
		</tr>

	</table>
</div>

<!--
<p>You don't have put a template into a file according to this mapping, because we
	can group multiple templates into the a single template file. When matrix.js load a
	template file, it will import all the templates defined in the file. If we decide to put a
	template x into a template file y, but the template x does not map to file name y according to
	the mapping, instead template z map to file name y, we need to make sure template z is
	referenced in our application before template x is referenced. For example, we want to put
	template "a.b" into matrix_resource/a/main.html, we need to make sure template "a" is referenced
	first before "a.b".
</p>
-->

<h2>Building large scale single page application.</h2>

<h3>Load application/model/view on demand</h3>

<p>In via.js, an application is composed of view and model. So far we are able
	to create an helloworld app with view and model, and we can even load our view (template) on
	demand. But our initial model are still statically embeded in the page. To be able to
	load application on demand, we need to be able to load model on demand. And here we use
	matrix.js loader again. The <a href="../demo/helloworld/19-loadApp.html">following code</a>
	shows how to load an application.
</p>

<ol class="simpleList">
	<li>We create a static root view in a page, the rootview
		has user subscription declaration @loadapp:helloApp.
		<pre class="brush:html">
					&lt;!--the root view--&gt;
					&lt;div data-sub="@loadapp:helloApp"&gt;&lt;/div&gt;
				</pre>
	</li>
	<li>This declaration will use matrix.js to load the definition of the "helloApp" application,
		then execute the definiton. Matrix.js will load and run the code defined in the file
		matrix_resource_folder\appLoader\helloApp.js. The code is as follow
		<pre class="brush:javascript">
					(function() {

						return {

							load: function( appContainer, options ) {

								//build the model first
								via.set( "helloAppModel", {
									prompt: "Please input your name:",
									name: "",
									message: function() {
										var name = this.get( "name" );
										return name ? "hello, " + name : "";
									}
								} );

								//render child view with external template, and model
								$( appContainer ).renderInside(
									"helloAppModel"/*modelPath*/,
									"hello" /*templateId*/
								);
							},

							unload: function() { }
						};
					})();
				</pre>
	</li>
	<li>The definition first load the model.

	</li>
	<li>When model is ready, the definition render its child view</li>
	<li>Because of the finalizer in template pipeline subscriptions are wired up declaratively. Then
		the application is loaded.
	</li>
</ol>

<!--The child view's subscription will be
	automatically build,
	and the child views also automatically build their child view. -->

<h3>Building large scale single page application.</h3>

<p>A large scale application can be built from smaller application. We can use the
	<strong><a href="http://en.wikipedia.org/wiki/Composite_pattern">
		composite pattern </a></strong> to build arbitrary complex application by composing smaller
	applications. We have seen how to load an application on demand. We can use the same
	the technique to build a large scale single page application. But these time the root view
	is the body element of the page. The root view dynamically load the root views of other small
	applications, and these root views recursively load other small application. Here is an
	<a href="../demo/app-demo/mashup.html">example</a>
</p>


<h2>Ajax</h2>

<p>The handler pipleine in via.js can support asynchrounous getters and converters which return a
	promise. When a promise is returned, pipeline will "wait" for the promise to deliver a real
	value. When the real value is delivered, the pipleline will resume and continue to process next
	filter with the delivered value. In fact, via.js support pipeline with both asynchrounous getter
	and asynchrounous converter. Since jQuery 1.5, $.ajax has been rewrittern to return a
	jqXHR which is a promise object. So we can just return the jqXHR in our getter and
	converter.
</p>

<p>
	In the <a href="../demo/helloworld/11-ajax-async-converter.html">following code</a>, the
	pipeline use a converter which send the name to server and get a message back using ajax.
</p>

<pre class="brush:html">
	&lt;!-- the div subscribe the change of model "name" using a handler with a async converter--&gt;
	&lt;div data-sub="!init after*:name|get html #..getMessage"/&gt;
</pre>
<pre class="brush:javascript">
	via.set( "test", {
      name: "",
      getMessage: function( value, e ) {
          return $.ajax( {
              url: "getMessage",
              dataType: 'json',
              data: JSON.stringify( value )
          } );
      }
  } );
</pre>

<p>A even more simple solution is to use asynchronous model function. The label
	can subscribe the change of the asynchronous model function like normal model function.
</p>
<pre class="brush:html">
	&lt;div data-sub="`html:message"/&gt;
</pre>
<pre class="brush:javascript">
	via.set( "test", {
	    name: "",
	    message: function() {
	        var name = this.get( "name" );
	        return $.ajax( {
	            url: "getMessage",
	            dataType: 'json',
	            data: JSON.stringify( name )
	        } );
	    }
	} );
</pre>


<h2>Beyond helloworld app</h2>

<p>The helloworld app is very simple, but I have used it to cover lots features of via.js. Please
	browse <a href="../demo/index.html">sample code</a> and check the <a
		href="../demo/app-demo/doc/doc.html">API documentation app</a> (which is still being built.)
</p>

</div>
</body>
</html>
