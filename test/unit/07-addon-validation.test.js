module( "07-addon-validation.test.js" );

test( "valdation", function () {

	via().create( "a", null );
	via.validate( "a", "required" )

	//	via.validate("a", {
	//		isValid: function (value) {
	//			return !$.isNaN(value) && (value >= 10);
	//		},
	//		error: "it must be over 9"
	//	});

	equal( via( "a" ).isValid(), false, "when a model is required, its value cannot be null" );
	equal( via( "a*errors" ).get().length, 1, "when validation fails, path*errors will has the error message" );

	via().create( "b", "" );
	via.validate( "b", "required" )

	equal( via( "b" ).isValid(), false, "when a model is required, its value cannot be empty string" );

	via().create( "c", 0 );
	via.validate( "c", "required" )

	equal( via( "c" ).isValid(), true, "when a model is required, its value can be 0" );

	via().create( "d", null );
	via.validate( "d", {
		isValid: function ( value ) {
			return false;
		},
		error: ""
	} );

	equal( via( "d" ).isValid(), true, "by default a model is not required, if it is null and it is not required, any validator is by-passed" );

	via().create( "e", 1 );
	via.validate( "e", {
		isValid: function ( value ) {
			return false;
		},
		error: ""
	} );

	equal( via( "e" ).isValid(), false, "a validator is called, when a value is not null" );

	via().create( "f", null );
	via.validate( "f", "required" )
		.validate( "f", {
			isValid: function ( value ) {
				return false;
			},
			error: "invalid1"
		} );

	via( "f" ).isValid();
	ok( via().get( "f*invalidated" ), "after isValid is called, path*invalidated is marked as true" );
	equal( via().get( "f*errors" ).length, 1, "if required validation is not passed, all remaining validators will be bypassed" );

	via().create( "g", 1 );
	via.validate( "g", {
		isValid: function ( value ) {
			return false;
		},
		error: "invalid1"
	} )
		.validate( "g", {
			isValid: function ( value ) {
				return false;
			},
			error: "invalid2"
		} );

	via( "g" ).isValid();
	var errors = via().get( "g*errors" );
	ok( (errors.length == 2 && errors.indexOf( "invalid1" ) != -1 && errors.indexOf( "invalid2" ) != -1),
		"path*errors is the summary of messages generated by all failed validations" );

	equal( via().isValid(), false, "parent model is invalid if any of child models is invalid" );

	via().create( "h", "h" );
	via.validate( "h", "number" );

	via( "h" ).isValid();
	equal( via().get( "h*errors" )[0], via.options( "errors" ).number, "error message can be preset in via.options('errors').validatorName" );

	via().create( "i", "i" );
	var myerror = "xxxx";
	via.validate( "i", "number", myerror );

	via( "i" ).isValid();
	equal( via().get( "i*errors" )[0], myerror, "error message can be set manually set as an option" );

	via.addValidator( {
		name: "dummy1",
		isValid: function ( value ) {
			return false;
		},
		error: "{1},{0}"
	} );

	via().create( "j", "j" );
	via.validate( "j", "dummy1", "a,b" );
	via( "j" ).isValid();
	equal( via().get( "j*errors" )[0], "b,a", "error message can be formatted" );

	via.addValidator( {
		name: "dummy2",
		isValid: function ( value ) {
			return false;
		},
		error: "a",
		buildError: function ( errorFormat, options ) {
			return errorFormat + "," + options;
		}
	} )
	via().create( "k", "k" );
	via.validate( "k", "dummy2", "b" );
	via( "k" ).isValid();
	equal( via().get( "k*errors" )[0], "a,b", "error message can be build with validator.buildError" );

	via().create( "l", "jskdjf" );
	via.validate( "l", "email" );
	via( "l" ).isValid();
	equal( via().get( "l*errors" )[0], via.options( "errors" ).email, "can check invalid email" );

	via().create( "m", "x@gmail.com" );
	via.validate( "m", "email" );
	ok( via( "m" ).isValid(), "can check valid email" );

	via().create( "n", "n" );
	via.validate( "n", "minlength", "2" );
	via( "n" ).isValid();
	equal( via().get( "n*errors" )[0], via.debug.format( via.options( "errors" ).minlength, 2 ), "minlength can check invalid input" );

	via().create( "o", "oo" );
	via.validate( "o", "minlength", "2" );
	ok( via( "o" ).isValid(), "minlength can check valid input" );

	via().create( "p", "ppp" );
	via.validate( "p", "maxlength", "2" );
	via( "p" ).isValid();
	equal( via().get( "p*errors" )[0], via.debug.format( via.options( "errors" ).maxlength, 2 ), "maxlength can check invalid input" );

	via().create( "q", "qq" );
	via.validate( "q", "maxlength", "2" );
	ok( via( "q" ).isValid(), "maxlength can check valid input" );

	via().create( "r", "r" );
	via.validate( "r", "rangelength", "2,3" );
	via( "r" ).isValid();
	equal( via().get( "r*errors" )[0], via.debug.format( via.options( "errors" ).rangelength, 2, 3 ), "rangelength can check invalid input" );

	via().create( "s", "sss" );
	via.validate( "s", "rangelength", "2,3" );
	ok( via( "s" ).isValid(), "rangelength can check valid input" );

	via().create( "t", 99 );
	via.validate( "t", "min", "100" );
	via( "t" ).isValid();
	equal( via().get( "t*errors" )[0], via.debug.format( via.options( "errors" ).min, 100 ), "min can check invalid input" );

	via().create( "u", 101 );
	via.validate( "u", "min", "100" );
	ok( via( "u" ).isValid(), "min can check valid input" );


	via().create( "v", 101 );
	via.validate( "v", "max", "100" );
	via( "v" ).isValid();
	equal( via().get( "v*errors" )[0], via.debug.format( via.options( "errors" ).max, 100 ), "max can check invalid input" );

	via().create( "x", 100 );
	via.validate( "x", "max", "100" );
	ok( via( "x" ).isValid(), "max can check valid input" );


	via().create( "y", 99 );
	via.validate( "y", "range", "100,200" );
	via( "y" ).isValid();
	equal( via().get( "y*errors" )[0], via.debug.format( via.options( "errors" ).range, 100, 200 ), "range can check invalid input" );

	via().create( "z", 101 );
	via.validate( "z", "range", "100,200" );
	ok( via( "z" ).isValid(), "range can check valid input" );

	via( "a" ).del();
	via( "b" ).del();
	via( "c" ).del();
	via( "d" ).del();
	via( "e" ).del();
	via( "f" ).del();
	via( "g" ).del();
	via( "h" ).del();
	via( "i" ).del();
	via( "j" ).del();
	via( "k" ).del();
	via( "l" ).del();
	via( "m" ).del();
	via( "n" ).del();
	via( "o" ).del();
	via( "p" ).del();
	via( "q" ).del();
	via( "r" ).del();
	via( "s" ).del();
	via( "t" ).del();
	via( "u" ).del();
	via( "v" ).del();
	via( "x" ).del();
	via( "y" ).del();
	via( "z" ).del();

	ok( via( "*invalidModelPaths" ).isModelEmpty(), "after a model is deleted, its path is removed from *invalidModelPaths" );
} );